{
    "1": {
       "task_id": "1",
        "code": "include \"/Users/pari/pcc-llms/dataset/filesystems/interface/effectful-interface.dfy\"\nmethod ReadFile(path: path) returns (data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(path)\nrequires IsValidFileExtension(path)\nensures ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.Open(path);\nif !ok { print \"open failed\\n\"; return new byte[0]; }\n data := new byte[100];\n ok := f.Read(path, 0, data, 0, data.Length as int32);\nprint \"Read operation terminated safely!\\n\";\n}",
        "method_signature": "method Append(path: seq<char>,  fname: seq<char>) returns (jointPath: path)",
        "task_description": "Write a code in Dafny to append a file to a path",
        "safety_properties": "All file system elements (paths and filenames) must be safe and non-dangerous.\nAll paths must be absolute and valid.\nAll filenames must be valid.\nAll file system elements must have valid lengths.\nAll paths must be non-empty.\nCombined file system elements must have valid lengths when joined.\nPath joining operations must produce valid results.\nResulting joined paths must have valid lengths or be empty. ",
        "verification_methods_signature": "-predicate IsDangerousPath(p: path)\n- predicate HasAbsolutePath(p: path)\n-  predicate IsValidPathName(path: string)\n -",
        "fileIO_methods_signature": "- static method FileStream.Open(fname: seq<char>) returns (ok: bool, f: FileStream) \n - method FileStream.Join(p: path, f: file) returns(result: path) \n  method FileStream.Read(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n method FileStream.Write(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method FileStream.Close() returns(ok:bool) \n method FileStream.Flush returns(ok:bool)"

           
    },
    "2": {
       "task_id": "2",
        "code": "include \"/Users/pari/pcc-llms/dataset/filesystems/interface/effectful-interface.dfy\"\nmethod SaveToFile(path: seq<char>, userData: seq<char>)\nrequires !IsDangerousPath(path)\nrequires HasValidPathLength(path)\nrequires NonEmptyString(path)\nrequires !IsDangerousPath(path)\nrequires StrContentLengthIsValid(userData)\nrequires HasAbsolutePath(path)\nrequires IsValidPathName(path)\nrequires IsValidFileName(userData)\nrequires IsValidFileExtension(path)\n{\nvar f: FileStream;\nvar ok: bool;\nvar data: array<byte> := ArrayFromSeq(StringToBytes(userData));\n ok, f := FileStream.Open(path);\nif !ok { print \"open failed\\n\"; return; }\nif ( data.Length == 0 ) { print \"Empty data\\n\"; return; }\n ok := f.Write(path, 0, data, 0, data.Length as int32);\nprint \"Safe write operation!\\n\";\n",
        "method_signature":  "method SaveToFile(fname: seq<char>)",
        "task_description": "Write a code in Dafny to save \"User's private data\" into a file ",
        "safety_properties": "All paths must be safe and valid.\nAll paths must have appropriate lengths.\nAll paths must be non-empty.\nAll paths must not contain potentially dangerous elements.\nAll paths must be well-formed.\nAll paths must be absolute.\nAll file extensions must be valid.\nAll user input must be properly validated.\nAll user-provided filenames must be valid. ",
        "verification_methods_signature": "-predicate IsValidFileName(filename: string): bool\n- predicate HasValidFileLength(f: file)\n- predicate IsValidPathName(path: string)\n- predicate StrContentLengthIsValid(content: string)\n- predicate ByteContentLengthIsValid(content: array<byte>)\n-predicate IsValidDir(p: path)\n- predicate HasValidPathLength(p: path)\n- predicate JointPathSize(p: path, f: file)\n- function PathJoin(p: path, f: file): seq<char> \n- function GetPathLength(pof: PathOrFile): nat\n- predicate IsDangerousPath(p: path)\n- predicate HasAbsolutePath(p: path)\n- function IsValidFileExtension(filename: string): bool\n- method ArrayFromSeq<A>(s: seq<A>) returns (a: array<A>)\n- predicate NonEmptyString(s: string)\n- predicate ContainsConsecutivePeriods(s: seq<char>)\n- predicate ContainsEncodedPeriods(s: seq<char>)\n- predicate ContainsParentDirTraversal(s: seq<char>)\n- predicate ContainsHomeDirReference(s: seq<char>)\n- predicate ContainsDriveLetter(s: seq<char>)\n- predicate ContainsDangerousPattern(s: seq<char>)\n",
         "fileIO_methods_signature": "- static method FileStream.Open(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method FileStream.Join(p: path, f: file) returns(result: path) \n- method FileStream.Read(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n- method FileStream.Write(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method FileStream.Close() returns(ok:bool) \n- method FileStream.Flush returns(ok:bool)"
    },
    "3": {
      "task_id": "3",
      "code": "include \"/Users/pari/pcc-llms/dataset/filesystems/interface/effectful-interface.dfy\"\nmethod ReadFile(path: seq<char>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(path)\nrequires IsValidFileExtension(path)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.Open(path);\nif !ok { print \"open failed\\n\"; return; }\nvar data: array<byte> := new byte[100];\n ok := f.Read(path, 0, data, 0, data.Length as int32);\nexpect ByteContentLengthIsValid(data);\nprint \"Safe Read operation!\\n\";\n}",
      "method_signature":  "method ReadFile(fPath: seq<char>)",
      "task_description": "Write a code in Dafny to read a file. File is provided by user.",
      "safety_properties": "The file path must not be considered dangerous.\n- The file path must be a valid path name.\n- The file path must be a non-empty string.\n The file must have a valid file extension.\n- The byte content length of the data must be valid after the operation.",
      "verification_methods_signature": "-predicate IsValidFileName(filename: string): bool\n- predicate HasValidFileLength(f: file)\n- predicate IsValidPathName(path: string)\n- predicate StrContentLengthIsValid(content: string)\n- predicate ByteContentLengthIsValid(content: array<byte>)\n-predicate IsValidDir(p: path)\n- predicate HasValidPathLength(p: path)\n- predicate JointPathSize(p: path, f: file)\n- function PathJoin(p: path, f: file): seq<char> \n- function GetPathLength(pof: PathOrFile): nat\n- predicate IsDangerousPath(p: path)\n- predicate HasAbsolutePath(p: path)\n- function IsValidFileExtension(filename: string): bool\n- method ArrayFromSeq<A>(s: seq<A>) returns (a: array<A>)\n- predicate NonEmptyString(s: string)\n- predicate ContainsConsecutivePeriods(s: seq<char>)\n- predicate ContainsEncodedPeriods(s: seq<char>)\n- predicate ContainsParentDirTraversal(s: seq<char>)\n- predicate ContainsHomeDirReference(s: seq<char>)\n- predicate ContainsDriveLetter(s: seq<char>)\n- predicate ContainsDangerousPattern(s: seq<char>)\n",
      "fileIO_methods_signature": "- static method FileStream.Open(fname: seq<char>) returns (ok: bool, f: FileStream) \n - method FileStream.Join(p: path, f: file) returns(result: path) \n  method FileStream.Read(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n method FileStream.Write(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method FileStream.Close() returns(ok:bool) \n method FileStream.Flush returns(ok:bool)"
    },
    "4": {
      "task_id": "4",
      "code": "include \"/Users/pari/pcc-llms/dataset/filesystems/interface/effectful-interface.dfy\"\nmethod WriteToFile(path: path, data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires HasValidPathLength(path)\nrequires IsValidFileExtension(path)\nrequires ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.Open(path);\nif !ok {\nprint \"open failed\\n\";\nreturn;\n }\n ok := f.Write(path, 0, data, 0, data.Length as int32);\nif !ok {\nprint \"write failed\\n\";\n } else {\nprint \"Safe write operation!\\n\";\n }\n}\nmethod ReadFile(path: path) returns (data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(path)\nrequires IsValidFileExtension(path)\nensures ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.Open(path);\nif !ok {\nprint \"open failed\\n\";\nreturn new byte[0];\n }\n data := new byte[100];\nvar dataLength: int32 := 100;\n ok := f.Read(path, 0, data, 0, dataLength);\nif !ok {\nprint \"read failed\\n\";\n data := new byte[0];\n } else {\nprint \"Safe Read operation!\\n\";\n }\n}\nmethod Copy(srcFile: seq<char>, dstFile: seq<char>)\nrequires IsValidPathName(srcFile)\nrequires IsValidPathName(dstFile)\nrequires NonEmptyString(srcFile)\nrequires NonEmptyString(dstFile)\nrequires IsValidFileExtension(srcFile)\nrequires IsValidFileExtension(dstFile)\nrequires !IsDangerousPath(srcFile)\nrequires !IsDangerousPath(dstFile)\nrequires HasValidPathLength(srcFile)\nrequires HasValidPathLength(dstFile)\n{\nvar data := ReadFile(srcFile);\nWriteToFile(dstFile, data);\n}",
      "method_signature":"method Copy(srcFile: seq<char>, dstFile: seq<char>)",
      "safety_properties": "- All file paths must be valid and non-empty.\n- All file paths must have valid extensions.\n- No file path should be considered dangerous.\n- All file paths must have lengths within acceptable limits.\n- The function must copy the contents of the source file to the destination file.",
      "task_description": "Write a code in Dafny that copies a file from one location to another",
      "verification_methods_signature": "-predicate IsValidFileName(filename: string): bool\n- predicate HasValidFileLength(f: file)\n- predicate IsValidPathName(path: string)\n- predicate StrContentLengthIsValid(content: string)\n- predicate ByteContentLengthIsValid(content: array<byte>)\n-predicate IsValidDir(p: path)\n- predicate HasValidPathLength(p: path)\n- predicate JointPathSize(p: path, f: file)\n- function PathJoin(p: path, f: file): seq<char> \n- function GetPathLength(pof: PathOrFile): nat\n- predicate IsDangerousPath(p: path)\n- predicate HasAbsolutePath(p: path)\n- function IsValidFileExtension(filename: string): bool\n- method ArrayFromSeq<A>(s: seq<A>) returns (a: array<A>)\n- predicate NonEmptyString(s: string)\n- predicate ContainsConsecutivePeriods(s: seq<char>)\n- predicate ContainsEncodedPeriods(s: seq<char>)\n- predicate ContainsParentDirTraversal(s: seq<char>)\n- predicate ContainsHomeDirReference(s: seq<char>)\n- predicate ContainsDriveLetter(s: seq<char>)\n- predicate ContainsDangerousPattern(s: seq<char>)\n",
      "fileIO_methods_signature": "- static method FileStream.Open(fname: seq<char>) returns (ok: bool, f: FileStream) \n - method FileStream.Join(p: path, f: file) returns(result: path) \n  method FileStream.Read(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n method FileStream.Write(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method FileStream.Close() returns(ok:bool) \n method FileStream.Flush returns(ok:bool)"
    },
    "5": {
      "task_id": "5",
      "code": "include \"/Users/pari/pcc-llms/dataset/filesystems/interface/effectful-interface.dfy\"\nmethod LoadUserData(path: seq<char>, userName: string) returns (data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidFileExtension(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(userName)\nrequires !IsDangerousPath(userName)\nrequires HasAbsolutePath(path)\nensures ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.Open(path);\nif !ok { print \"open failed\\n\"; return new byte[0]; }\n data := new byte[100];\n ok := f.Read(path, 0, data, 0, data.Length as int32);\nprint \"User data loaded!\\n\";\n}",
      "method_signature": "method LoadUserData(path: path, userName: string) returns (data: array<byte>)",
      "safety_properties": "- All file paths must be safe and non-dangerous.\n- All file paths must be valid and well-formed.\n- All file paths must be non-empty.\n- All file extensions must be valid.\n- All read operations must return data of valid length.\n",
      "task_description": "Write a code in Dafny to get a username and a path as inputs and loads user's data from the given path if a file with that username exists",
      "verification_methods_signature": "-predicate IsValidFileName(filename: string): bool\n- predicate HasValidFileLength(f: file)\n- predicate IsValidPathName(path: string)\n- predicate StrContentLengthIsValid(content: string)\n- predicate ByteContentLengthIsValid(content: array<byte>)\n-predicate IsValidDir(p: path)\n- predicate HasValidPathLength(p: path)\n- predicate JointPathSize(p: path, f: file)\n- function PathJoin(p: path, f: file): seq<char> \n- function GetPathLength(pof: PathOrFile): nat\n- predicate IsDangerousPath(p: path)\n- predicate HasAbsolutePath(p: path)\n- function IsValidFileExtension(filename: string): bool\n- method ArrayFromSeq<A>(s: seq<A>) returns (a: array<A>)\n- predicate NonEmptyString(s: string)\n- predicate ContainsConsecutivePeriods(s: seq<char>)\n- predicate ContainsEncodedPeriods(s: seq<char>)\n- predicate ContainsParentDirTraversal(s: seq<char>)\n- predicate ContainsHomeDirReference(s: seq<char>)\n- predicate ContainsDriveLetter(s: seq<char>)\n- predicate ContainsDangerousPattern(s: seq<char>)\n",
      "fileIO_methods_signature": "- static method FileStream.Open(fname: seq<char>) returns (ok: bool, f: FileStream) \n - method FileStream.Join(p: path, f: file) returns(result: path) \n  method FileStream.Read(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n method FileStream.Write(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method FileStream.Close() returns(ok:bool) \n method FileStream.Flush returns(ok:bool)"    }
}