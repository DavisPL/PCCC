{
    "1": {
       "task_id": "1",
       "task_description": "Write a code in Dafny to append a file to a path",
       "method_signature": "method Append(path: seq<char>,  fname: seq<char>) returns (jointPath: path)",
        "code": "method ReadFile(path: path) returns (data: array<byte>)\nrequires !IsDangerousPath(path)\n requires !IsDangerousPath(fname)\nrequires IsValidPathName(path)\nrequires NonEmptyString(path)\nrequires IsValidFileExtension(path)\nensures ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.SafeOpenAPIFile(path);\nif !ok { print \"open failed\\n\"; return new byte[0]; }\n data := new byte[100];\n ok := f.Read(path, 0, data, 0, data.Length as int32);\nprint \"Read operation terminated safely!\\n\";\n}",
        "safety_properties": "-Open the given file and handle exeptions if any occured \n- Prevent path traversal by avoiding any dangerous pattern in the file name\n - Prevent path traversal by avoiding any dangerous pattern in the path\n- Prevent any relative path in the file name\n- Prevent any invalid pattern in the path\n- Prevent any invalid pattern in the file name\n- Prevent file name length from exceeding the maximum limit\n- Prevent path length from exceeding the maximum limit\n- Verifies that the path and file name are joined safely without navigation outside the intended directory ",
        "spec": {
        "verification_conditions": "- requires !IsDangerousPath(fname) \n- requires !IsDangerousPath(path) \n- requires HasAbsolutePath(fname) \n- requires IsValidPathName(path) \n- requires IsValidFileName(fname) \n- requires HasValidFileLength(fname) \n- requires HasValidPathLength(path) \n- requires HasValidPathLength(path + fname) \n- ensures PathJoin(path, fname) == jointPath  || jointPath == \"\" \n- ensures HasValidPathLength(jointPath) || 0 <= |jointPath| \n",
        "verification_methods_signature": "- predicate IsDangerousPath(filename: seq<char>)\n- predicate IsDangerousPath(path: seq<char>)\n- predicate HasAbsolutePath(filename: seq<char>)\n- predicate IsValidPathName(path: seq<char>)\n predicate IsValidFileName(filename: seq<char>)\n- redicate HasValidFileLength(filename: seq<char>)\n- predicate HasValidPathLength(path: seq<char>)\n- function PathJoin(p: seq<char>, f: seq<char>): seq<char>" 
       },
        "fileIO_methods_signature": "- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n - method SafeJoinAPI(p: path, f: file) returns(result: path)",
        "available_fileIO_methods":"- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeJoinAPI(p: path, f: file) returns(result: path) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n- method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method SafeCloseAPI() returns(ok:bool) \n- method SafeFlushAPI returns(ok:bool)"
           
    },
    "2": {
       "task_id": "2",
       "task_description": "Write a code in Dafny to save \"User's private data\" into a file ",
       "method_signature":  "method SaveToFile(fname: seq<char>)",
       "code": "method SaveToFile(path: seq<char>, userData: seq<char>)\nrequires !IsDangerousPath(path)\nrequires HasValidPathLength(path)\nrequires NonEmptyString(path)\nrequires StrContentLengthIsValid(userData)\nrequires HasAbsolutePath(path)\nrequires IsValidPathName(path)\nrequires IsValidFileName(userData)\nrequires IsValidFileExtension(path)\n{\nvar f: FileStream;\nvar ok: bool;\nvar data: array<byte> := ArrayFromSeq(StringToBytes(userData));\n ok, f := FileStream.SafeOpenAPI(path);\nif !ok { print \"open failed\\n\"; return; }\nif ( data.Length == 0 ) { print \"Empty data\\n\"; return; }\n ok := f.Write(path, 0, data, 0, data.Length as int32);\nprint \"Safe write operation!\\n\";\n",
      "safety_properties": "-Open the given file and handle exeptions if any occured \n- Prevent path traversal by avoiding any dangerous pattern in the path\n- Prevent path length from exceeding the maximum limit\n- Verifies path is not empty\n- Verifies that the new data to be written to a file does not exceed the maximum limit\n- Prevent using any relative path\n- Prevent any invalid pattern in the path\n- Prevent any invalid pattern in the file name\n- Verifies that file extension is valid",
      "spec": {
        "verification_conditions": "- requires !IsDangerousPath(path)\n- requires HasValidPathLength(path)\n- require s NonEmptyString(path)\n- requires StrContentLengthIsValid(userData)\n- requires HasAbsolutePath(path)\n- requires IsValidPathName(path)\n- requires IsValidFileName(userData)\n- requires IsValidFileExtension(path)\n ",
        "verification_methods_signature": "- predicate IsDangerousPath(path: seq<char>)\n- predicate HasValidPathLength(p: seq<char>)\n- predicate NonEmptyString(s: seq<char>)\n- predicate StrContentLengthIsValid(content: string)\n- predicate HasAbsolutePath(path: seq<char>)\n- predicate IsValidPathName(path: seq<char>)\n- predicate IsValidFileName(filename: seq<char>)\n- predicate IsValidFileExtension(filename: seq<char>)"
      },
      "fileIO_methods_signature": "- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n",
      "available_fileIO_methods":"- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeJoinAPI(p: path, f: file) returns(result: path) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n- method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method SafeCloseAPI() returns(ok:bool) \n- method SafeFlushAPI returns(ok:bool)"
          
        },
    "3": {
      "task_id": "3",
      "task_description": "Write a code in Dafny to read a file. File is provided by user.",
      "method_signature":  "method ReadFile(fPath: seq<char>)",
      "code": "method ReadFile(path: seq<char>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(path)\nrequires IsValidFileExtension(path)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.SafeOpenAPI(path);\nif !ok { print \"open failed\\n\"; return; }\nvar data: array<byte> := new byte[100];\n ok := f.Read(path, 0, data, 0, data.Length as int32);\nexpect ByteContentLengthIsValid(data);\nprint \"Safe Read operation!\\n\";\n}",
      "safety_properties": "-Open the given file and handle exeptions if any occured \n- Prevent path traversal by avoiding any dangerous pattern in the path\n- Prevent any invalid pattern in the path\n- Verifies path is not empty\n- Verifies that file extension is valid\n- Verifies that the content to be read from a file does not exceed the maximum limit",
      "spec": {
        "verification_conditions": "- predicate IsDangerousPath(p: seq<char>)\n- predicate IsValidPathName(path: seq<char>)\n- predicate NonEmptyString(s: seq<char>)\n- predicate IsValidFileExtension(filename: seq<char>)\n- predicate ByteContentLengthIsValid(content: array<byte>)\n",
        "verification_methods_signature": "- requires !IsDangerousPath(path)\n- requires IsValidPathName(path)\n- requires NonEmptyString(path)\n- requires IsValidFileExtension(path)\n- ensures ByteContentLengthIsValid(data)\n"
      },
     "fileIO_methods_signature": "- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)",
     "available_fileIO_methods":"- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeJoinAPI(p: path, f: file) returns(result: path) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n- method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method SafeCloseAPI() returns(ok:bool) \n- method SafeFlushAPI returns(ok:bool)"
          
    },
    "4": {
      "task_id": "4",
      "task_description": "Write a code in Dafny that copies a file from one location to another",
      "method_signature":"method Copy(srcFile: seq<char>, dstFile: seq<char>)",
      "code": "method WriteToFile(path: path, data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires HasValidPathLength(path)\nrequires IsValidFileExtension(path)\nrequires ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.SafeOpenAPI(path);\nif !ok {\nprint \"open failed\\n\";\nreturn;\n }\n ok := f.Write(path, 0, data, 0, data.Length as int32);\nif !ok {\nprint \"write failed\\n\";\n } else {\nprint \"Safe write operation!\\n\";\n }\n}\nmethod ReadFile(path: path) returns (data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(path)\nrequires IsValidFileExtension(path)\nensures ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.SafeOpenAPI(path);\nif !ok {\nprint \"open failed\\n\";\nreturn new byte[0];\n }\n data := new byte[100];\nvar dataLength: int32 := 100;\n ok := f.Read(path, 0, data, 0, dataLength);\nif !ok {\nprint \"read failed\\n\";\n data := new byte[0];\n } else {\nprint \"Safe Read operation!\\n\";\n }\n}\nmethod Copy(srcFile: seq<char>, dstFile: seq<char>)\nrequires IsValidPathName(srcFile)\nrequires IsValidPathName(dstFile)\nrequires NonEmptyString(srcFile)\nrequires NonEmptyString(dstFile)\nrequires IsValidFileExtension(srcFile)\nrequires IsValidFileExtension(dstFile)\nrequires !IsDangerousPath(srcFile)\nrequires !IsDangerousPath(dstFile)\nrequires HasValidPathLength(srcFile)\nrequires HasValidPathLength(dstFile)\n{\nvar data := ReadFile(srcFile);\nWriteToFile(dstFile, data);\n}",
      "safety_properties": "-Open the given file and handle exeptions if any occured \n- Prevent any invalid pattern in the path\n- Verifies path is not empty\n- Verifies that file extension is valid\n- Prevent path traversal by avoiding any dangerous pattern in the file name\n- Prevent path length from exceeding the maximum limit\n- Verifies that the content to be read from a file does not exceed the maximum limit",
      "spec": {
        "verification_conditions": "- predicate IsValidPathName(path: seq<char>)\n- predicate NonEmptyString(s: seq<char>)\n- predicate IsValidFileExtension(filename: seq<char>)\n- predicate IsDangerousPath(filename: seq<char>)\n- predicate HasValidPathLength(path: seq<char>)\n- predicate ByteContentLengthIsValid(content: array<byte>)",
        "verification_methods_signature": "- requires IsValidPathName(srcFile)\n- requires IsValidPathName(dstFile)\n- requires NonEmptyString(srcFile)\n- requires NonEmptyString(dstFile)\n- requires IsValidFileExtension(srcFile)\n- requires IsValidFileExtension(dstFile)\n- requires !IsDangerousPath(srcFile)\n- requires !IsDangerousPath(dstFile)\n- requires HasValidPathLength(srcFile)\n- requires HasValidPathLength(dstFile)\n- ensures ByteContentLengthIsValid(data)\n- requires ByteContentLengthIsValid(data)"
      
      },
     "fileIO_methods_signature": "- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n",
     "available_fileIO_methods":"- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeJoinAPI(p: path, f: file) returns(result: path) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n- method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method SafeCloseAPI() returns(ok:bool) \n- method SafeFlushAPI returns(ok:bool)"
          
    },
    "5": {
      "task_id": "5",
      "task_description": "Write a code in Dafny to get a username and a path as inputs and loads user's data from the given path if a file with that username exists",
      "method_signature": "method LoadUserData(path: path, userName: string) returns (data: array<byte>)",
      "code": "method LoadUserData(path: seq<char>, userName: string) returns (data: array<byte>)\nrequires !IsDangerousPath(path)\nrequires IsValidFileExtension(path)\nrequires IsValidPathName(path)\nrequires NonEmptyString(userName)\nrequires !IsDangerousPath(userName)\nrequires HasAbsolutePath(path)\nensures ByteContentLengthIsValid(data)\n{\nvar f: FileStream;\nvar ok: bool;\n ok, f := FileStream.SafeOpenAPI(path);\nif !ok { print \"open failed\\n\"; return new byte[0]; }\n data := new byte[100];\n ok := f.Read(path, 0, data, 0, data.Length as int32);\nprint \"User data loaded!\\n\";\n}",
      "safety_properties": "-Open the given file and handle exeptions if any occured \n- Prevent path traversal by avoiding any dangerous pattern in the path\n- Verifies that file extension is valid\n- Prevent any invalid pattern in the path\n- Verifies no user input is not empty\n- Verifies user input does not contain any dangerous pattern related to path traversal\n- Prevent using any relative path\n- Verifies that the content to be read from a file does not exceed the maximum limit",
      "spec": {
        "verification_conditions": "- predicate IsDangerousPath(path: seq<char>)\n- predicate IsValidFileExtension(filename: seq<char>)\n- predicate IsValidPathName(path: seq<char>)\n- predicate NonEmptyString(s: seq<char>)\n- predicate HasAbsolutePath(p: seq<char>)\n- predicate ByteContentLengthIsValid(content: array<byte>)\n",
        "verification_methods_signature": "- requires !IsDangerousPath(path)\n- requires IsValidFileExtension(path)\n- requires IsValidPathName(path)\n- requires NonEmptyString(userName)\n- requires !IsDangerousPath(userName)\n- requires HasAbsolutePath(path)\n- ensures ByteContentLengthIsValid(data)\n"
      },
      "fileIO_methods_signature": "- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n  method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)",
      "available_fileIO_methods":"- static method FileStream.SafeOpenAPI(fname: seq<char>) returns (ok: bool, f: FileStream) \n- method SafeJoinAPI(p: path, f: file) returns(result: path) \n- method SafeReadAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool) \n- method SafeWriteAPI(p: path, fileOffset:nat32, buffer:array<byte>, start:int32, end:int32) returns(ok:bool)\n method SafeCloseAPI() returns(ok:bool) \n- method SafeFlushAPI returns(ok:bool)"
       }
}